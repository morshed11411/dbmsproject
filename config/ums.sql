drop table 	ADVANCETRAINING	cascade constraints;
drop table 	APPOINTMENTS	cascade constraints;
drop table 	AUTHORIZATION	cascade constraints;
drop table 	BASICTRAINING	cascade constraints;
drop table 	CARRIERPLAN	cascade constraints;
drop table 	COMPANY	cascade constraints;
drop table 	CONTACTNUMBER	cascade constraints;
drop table 	LEAVEMODULE	cascade constraints;
drop table 	MEDICALINFO	cascade constraints;
drop table 	PUNISHMENT	cascade constraints;
drop table 	RANKS	cascade constraints;
drop table 	SOLDIER	cascade constraints;
drop table 	SOLDIERAPPOINTMENT	cascade constraints;
drop table 	SOLDIERBASICTRAINING	cascade constraints;
drop table 	SOLDIERTEAM	cascade constraints;
drop table 	TEAM	cascade constraints;
drop table 	TRADE	cascade constraints;


-- CREATE  TABLES
CREATE TABLE TRADE (
  TRADEID NUMBER PRIMARY KEY,
  TRADE VARCHAR2(255)
);

CREATE TABLE RANKS (
  RANKID NUMBER PRIMARY KEY,
  RANK VARCHAR2(255)
);

CREATE TABLE COMPANY (
  COMPANYID NUMBER PRIMARY KEY,
  COMPANYNAME VARCHAR2(255)
);

CREATE TABLE SOLDIER (
  SOLDIERID NUMBER(7) PRIMARY KEY,
  PASSWORD NUMBER(8),
  NAME VARCHAR2(255),
  MARITALSTATUS VARCHAR2(255),
  BLOODGROUP VARCHAR2(255),
  WEIGHT NUMBER,
  HEIGHT NUMBER,
  RELIGION VARCHAR2(255),
  DATEOFBIRTH DATE,
  GENDER VARCHAR2(255),
  LIVINGSTATUS VARCHAR2(255),
  VILLAGE VARCHAR2(255),
  THANA VARCHAR2(255),
  DISTRICT VARCHAR2(255),
  DATEOFENROLL DATE,
  TEMPORARYCOMMAND VARCHAR2(255) DEFAULT 'NO',
  ERE VARCHAR2(255) DEFAULT 'NO',
  SERVINGSTATUS VARCHAR2(255) DEFAULT 'SERVING',
  TRADEID NUMBER,
  RANKID NUMBER,
  COMPANYID NUMBER,
  ACCESSROLE VARCHAR2(255) DEFAULT 'SOLDIER',
  FOREIGN KEY (TRADEID) REFERENCES TRADE(TRADEID),
  FOREIGN KEY (RANKID) REFERENCES RANKS(RANKID),
  FOREIGN KEY (COMPANYID) REFERENCES COMPANY(COMPANYID)
);

CREATE TABLE CONTACTNUMBER (
  SOLDIERID NUMBER,
  CONTACTNUMBER NUMBER(11),
  FOREIGN KEY (SOLDIERID) REFERENCES SOLDIER(SOLDIERID)
);

CREATE TABLE PUNISHMENT (
  PUNISHMENTID NUMBER PRIMARY KEY,
  SOLDIERID NUMBER,
  PUNISHMENT VARCHAR2(255),
  REASON VARCHAR2(255),
  PUNISHMENTDATE DATE,
  FOREIGN KEY (SOLDIERID) REFERENCES SOLDIER(SOLDIERID)
);

CREATE TABLE TEAM (
  TEAMID NUMBER PRIMARY KEY,
  TEAMNAME VARCHAR2(255),
  STARTDATE DATE,
  ENDDATE DATE,
  TEAMOIC VARCHAR2(255)
);



CREATE TABLE AUTHORIZATION (
  MANPOWER NUMBER,
  COMPANYID NUMBER,
  FOREIGN KEY (COMPANYID) REFERENCES COMPANY(COMPANYID)
);



CREATE TABLE MEDICALINFO (
  MEDICALID NUMBER PRIMARY KEY,
  SOLDIERID NUMBER,
  DISPOSALTYPE VARCHAR2(255),
  STARTDATE DATE,
  ENDDATE DATE,
  REASON VARCHAR2(255),
  FOREIGN KEY (SOLDIERID) REFERENCES SOLDIER(SOLDIERID)
);



CREATE TABLE APPOINTMENTS (
  APPOINTMENTID NUMBER PRIMARY KEY,
  APPOINTMENTNAME VARCHAR2(255)
);

CREATE TABLE LEAVEMODULE (
  LEAVEID NUMBER PRIMARY KEY,
  SOLDIERID NUMBER,
  LEAVETYPE VARCHAR2(255),
  LEAVESTARTDATE DATE,
  LEAVEENDDATE DATE,
  FOREIGN KEY (SOLDIERID) REFERENCES SOLDIER(SOLDIERID)
);

CREATE TABLE CARRIERPLAN (
  SOLDIERID NUMBER(7) PRIMARY KEY,
  FIRSTCYCLE VARCHAR2(255),
  SECONDCYCLE VARCHAR2(255),
  THIRDCYCLE VARCHAR2(255),
  FOURTHCYCLE VARCHAR2(255),
  FOREIGN KEY (SOLDIERID) REFERENCES SOLDIER(SOLDIERID)
);

CREATE TABLE ADVANCETRAINING (
  CADREID NUMBER PRIMARY KEY,
  NAME VARCHAR2(255),
  TRAININGSTARTDATE DATE,
  TRAININGENDDATE DATE,
  TRAININGOIC VARCHAR2(255),
  INSTRUCTOR VARCHAR2(255),
  RESULT VARCHAR2(255)
);

CREATE TABLE BASICTRAINING (
  TRAININGID NUMBER PRIMARY KEY,
  TRAININGCODE VARCHAR2(255),
  TRAININGNAME VARCHAR2(255)
);

CREATE TABLE SOLDIERBASICTRAINING (
  TRAININGID NUMBER,
  TRAININGDATE DATE,
  SOLDIERID NUMBER,
  REMARK VARCHAR2(255),
  FOREIGN KEY (TRAININGID) REFERENCES BASICTRAINING(TRAININGID),
  FOREIGN KEY (SOLDIERID) REFERENCES SOLDIER(SOLDIERID)
);


CREATE TABLE SOLDIERAPPOINTMENT (
  SOLDIERID NUMBER,
  APPOINTMENTID NUMBER,
  FOREIGN KEY (SOLDIERID) REFERENCES SOLDIER(SOLDIERID),
  FOREIGN KEY (APPOINTMENTID) REFERENCES APPOINTMENTS(APPOINTMENTID)
);

CREATE TABLE SOLDIERTEAM (
  SOLDIERID NUMBER,
  TEAMID NUMBER,
  FOREIGN KEY (SOLDIERID) REFERENCES SOLDIER(SOLDIERID),
  FOREIGN KEY (TEAMID) REFERENCES TEAM(TEAMID)
);




--CREATE VIEWS


CREATE OR REPLACE VIEW MANAGE_COMPANY_VIEW AS
SELECT
  C.COMPANYID,
  C.COMPANYNAME,
  S.NAME AS "COY COMD",
  (SELECT COUNT(*) FROM SOLDIER WHERE COMPANYID = C.COMPANYID) AS TOTALMANPOWER
FROM
  COMPANY C
  JOIN SOLDIER S ON C.COMPANYID = S.COMPANYID
  JOIN SOLDIERAPPOINTMENT SA ON S.SOLDIERID = SA.SOLDIERID
  JOIN APPOINTMENTS A ON SA.APPOINTMENTID = A.APPOINTMENTID
WHERE
  A.APPOINTMENTNAME = 'COY COMD';



CREATE OR REPLACE VIEW TODAYS_LEAVE_VIEW AS
SELECT S.SOLDIERID, S.NAME, R.RANK, T.TRADE, C.COMPANYNAME, L.LEAVETYPE, L.LEAVESTARTDATE, L.LEAVEENDDATE,
       (L.LEAVEENDDATE - TRUNC(SYSDATE)) AS REMAININGLEAVE
FROM SOLDIER S
JOIN RANKS R ON S.RANKID = R.RANKID
JOIN TRADE T ON S.TRADEID = T.TRADEID
JOIN COMPANY C ON S.COMPANYID = C.COMPANYID
JOIN LEAVEMODULE L ON S.SOLDIERID = L.SOLDIERID
WHERE L.LEAVESTARTDATE <= TRUNC(SYSDATE)
AND L.LEAVEENDDATE >= TRUNC(SYSDATE);

  CREATE OR REPLACE  VIEW TODAYS_DISPOSAL_HOLDER AS 
  SELECT S.SOLDIERID, S.NAME, R.RANK, T.TRADE, C.COMPANYNAME, M.DISPOSALTYPE, M.STARTDATE, M.ENDDATE
FROM SOLDIER S
JOIN RANKS R ON S.RANKID = R.RANKID
JOIN TRADE T ON S.TRADEID = T.TRADEID
JOIN COMPANY C ON S.COMPANYID = C.COMPANYID
JOIN MEDICALINFO M ON S.SOLDIERID = M.SOLDIERID
WHERE TRUNC(M.STARTDATE) <= TRUNC(SYSDATE)
  AND TRUNC(M.ENDDATE) >= TRUNC(SYSDATE);


CREATE OR REPLACE VIEW ABSENTSOLDIERSVIEW AS
SELECT S.SOLDIERID, S.NAME, R.RANK, C.COMPANYNAME, 'ERE' AS REASON 
FROM SOLDIER S
JOIN RANKS R ON S.RANKID = R.RANKID
JOIN COMPANY C ON S.COMPANYID = C.COMPANYID
WHERE S.ERE = 'YES'
UNION
SELECT S.SOLDIERID, S.NAME, R.RANK, C.COMPANYNAME, 'TEMPORARY COMMAND' AS REASON 
FROM SOLDIER S
JOIN RANKS R ON S.RANKID = R.RANKID
JOIN COMPANY C ON S.COMPANYID = C.COMPANYID
WHERE S.TEMPORARYCOMMAND = 'YES'
UNION
SELECT S.SOLDIERID, S.NAME, R.RANK, C.COMPANYNAME, 'AWOL' AS REASON 
FROM SOLDIER S
JOIN RANKS R ON S.RANKID = R.RANKID
JOIN COMPANY C ON S.COMPANYID = C.COMPANYID
WHERE S.SERVINGSTATUS = 'AWOL'
UNION
SELECT TL.SOLDIERID, S.NAME, R.RANK, C.COMPANYNAME, TL.LEAVETYPE AS REASON
FROM TODAYS_LEAVE_VIEW TL
JOIN SOLDIER S ON TL.SOLDIERID = S.SOLDIERID
JOIN RANKS R ON S.RANKID = R.RANKID
JOIN COMPANY C ON S.COMPANYID = C.COMPANYID
UNION
SELECT M.SOLDIERID, S.NAME, R.RANK, C.COMPANYNAME, M.DISPOSALTYPE AS REASON
FROM TODAYS_DISPOSAL_HOLDER M
JOIN SOLDIER S ON M.SOLDIERID = S.SOLDIERID
JOIN RANKS R ON S.RANKID = R.RANKID
JOIN COMPANY C ON S.COMPANYID = C.COMPANYID;



--FUNCTION IS PRESENT


CREATE OR REPLACE FUNCTION CALCULATEISPRESENT(P_SOLDIER_ID IN NUMBER)
  RETURN NUMBER
DETERMINISTIC
IS
  L_LEAVE_COUNT NUMBER;
  L_TEMP_COMMAND VARCHAR2(3);
  L_ERE VARCHAR2(3);
  L_SERVING_STATUS VARCHAR2(10);
  L_DISPOSAL_COUNT NUMBER;
BEGIN
  -- CHECK IF THE SOLDIER IS ON LEAVE
  SELECT COUNT(*) INTO L_LEAVE_COUNT
  FROM LEAVEMODULE
  WHERE SOLDIERID = P_SOLDIER_ID
    AND LEAVESTARTDATE <= TRUNC(SYSDATE)
    AND LEAVEENDDATE >= TRUNC(SYSDATE);

  -- CHECK THE SOLDIER'S TEMPORARY COMMAND, ERE, AND SERVING STATUS
  SELECT TEMPORARYCOMMAND, ERE, SERVINGSTATUS
  INTO L_TEMP_COMMAND, L_ERE, L_SERVING_STATUS
  FROM SOLDIER
  WHERE SOLDIERID = P_SOLDIER_ID;
  
  -- CHECK IF THE SOLDIER HAS A DISPOSAL TODAY
  SELECT COUNT(*) INTO L_DISPOSAL_COUNT
  FROM MEDICALINFO
  WHERE SOLDIERID = P_SOLDIER_ID
    AND TRUNC(STARTDATE) <= TRUNC(SYSDATE)
    AND TRUNC(ENDDATE) >= TRUNC(SYSDATE);

  -- RETURN 0 IF SOLDIER IS ON LEAVE, HAS A DISPOSAL TODAY, OR MEETS ADDITIONAL CONDITIONS, 1 OTHERWISE
  RETURN CASE
    WHEN L_LEAVE_COUNT > 0 THEN 0
    WHEN L_TEMP_COMMAND = 'YES' OR L_ERE = 'YES' OR L_SERVING_STATUS <> 'SERVING' OR L_DISPOSAL_COUNT > 0 THEN 0
    ELSE 1
  END;
END;
/



ALTER TABLE SOLDIER ADD ISPRESENT NUMBER GENERATED ALWAYS AS (CALCULATEISPRESENT(SOLDIERID)) VIRTUAL;



CREATE OR REPLACE VIEW PARADE_STATE_VIEW AS
SELECT
  C.COMPANYNAME,
  A.MANPOWER AS "AUTH",
  COUNT(S.SOLDIERID) AS "GRANTED",
  COUNT(L.SOLDIERID) AS "LEAVE",
  COUNT(CASE WHEN S.ISPRESENT = 0 THEN 1 END) AS "ABSENT",
  COUNT(S.SOLDIERID) - COUNT(CASE WHEN S.ISPRESENT = 0 THEN 1 END) AS "PRESENT",
  COUNT(D.SOLDIERID) AS "MEDICALDISPOSAL"
FROM
  COMPANY C
LEFT JOIN
  AUTHORIZATION A ON C.COMPANYID = A.COMPANYID
LEFT JOIN
  SOLDIER S ON C.COMPANYID = S.COMPANYID
LEFT JOIN
  TODAYS_LEAVE_VIEW L ON S.SOLDIERID = L.SOLDIERID
LEFT JOIN
  TODAYS_DISPOSAL_HOLDER D ON S.SOLDIERID = D.SOLDIERID
GROUP BY
  C.COMPANYNAME, A.MANPOWER;


/

CREATE OR REPLACE FUNCTION CALCULATEAGE(DATEOFBIRTH DATE) RETURN NUMBER DETERMINISTIC IS
BEGIN
  RETURN TRUNC(MONTHS_BETWEEN(SYSDATE, DATEOFBIRTH) / 12);
END;
/

ALTER TABLE SOLDIER ADD AGE NUMBER GENERATED ALWAYS AS (CALCULATEAGE(DATEOFBIRTH));


CREATE OR REPLACE VIEW SOLDIER_VIEW AS 
SELECT
  S.SOLDIERID,  S.PASSWORD,  S.NAME,  S.MARITALSTATUS,  S.BLOODGROUP,  S.WEIGHT,  S.HEIGHT,  S.RELIGION,  S.AGE,  S.DATEOFBIRTH,  S.GENDER,  S.LIVINGSTATUS,  S.VILLAGE,  S.THANA,  S.DISTRICT,  S.DATEOFENROLL,  S.TEMPORARYCOMMAND,  S.ERE,  S.SERVINGSTATUS,  S.TRADEID,  T.TRADE,  S.RANKID,  R.RANK,  S.COMPANYID,  C.COMPANYNAME,  S.ISPRESENT,  S.ACCESSROLE
FROM SOLDIER S
LEFT JOIN TRADE T ON S.TRADEID = T.TRADEID
LEFT JOIN RANKS R ON S.RANKID = R.RANKID
LEFT JOIN COMPANY C ON S.COMPANYID = C.COMPANYID;


  CREATE OR REPLACE VIEW OVERWEIGHTSOLDIERSVIEW AS
  SELECT S.SOLDIERID, R.RANK, T.TRADE, S.NAME, C.COMPANYNAME,
    CASE
        WHEN ((S.WEIGHT * 0.453592) / ((S.HEIGHT / 100) * (S.HEIGHT / 100))) > 25 THEN ROUND(((S.WEIGHT * 0.453592) / ((S.HEIGHT / 100) * (S.HEIGHT / 100))) - 25)
        ELSE 0
    END AS POUNDSOVERWEIGHT
FROM SOLDIER S
JOIN RANKS R ON S.RANKID = R.RANKID
JOIN TRADE T ON S.TRADEID = T.TRADEID
JOIN COMPANY C ON S.COMPANYID = C.COMPANYID
WHERE ((S.WEIGHT * 0.453592) / ((S.HEIGHT / 100) * (S.HEIGHT / 100))) > 25;





--CREATE SEQUENCE

CREATE SEQUENCE MEDICALIDSEQ
  START WITH 1
  INCREMENT BY 1
  NOMAXVALUE;

  

  --CREATE TRIGGER

  
CREATE OR REPLACE TRIGGER CHECK_MEDICAL_DISPOSAL_TRIGGER
BEFORE INSERT ON MEDICALINFO
FOR EACH ROW
DECLARE
    DISPOSAL_COUNT NUMBER;
BEGIN
    -- CHECK IF THERE ARE ANY OVERLAPPING DISPOSAL DATES FOR THE SOLDIER
    SELECT COUNT(*) INTO DISPOSAL_COUNT
    FROM MEDICALINFO
    WHERE SOLDIERID = :NEW.SOLDIERID
        AND ((:NEW.STARTDATE >= STARTDATE AND :NEW.STARTDATE <= ENDDATE)
            OR (:NEW.ENDDATE >= STARTDATE AND :NEW.ENDDATE <= ENDDATE));
            
    -- IF THERE ARE OVERLAPPING DISPOSAL DATES, RAISE AN EXCEPTION
    IF DISPOSAL_COUNT > 0 THEN
        RAISE_APPLICATION_ERROR(-20001, 'MEDICAL DISPOSAL DATES OVERLAP FOR THE SOLDIER');
    END IF;
END;
/



CREATE OR REPLACE TRIGGER MEDICALIDTRIGGER
BEFORE INSERT ON MEDICALINFO
FOR EACH ROW
BEGIN
  SELECT MEDICALIDSEQ.NEXTVAL INTO :NEW.MEDICALID FROM DUAL;
END;
/


CREATE OR REPLACE TRIGGER CHECK_LEAVE_TRIGGER
BEFORE INSERT OR UPDATE ON LEAVEMODULE
FOR EACH ROW
DECLARE
    LEAVE_COUNT NUMBER;
BEGIN
    -- CHECK IF THE SOLDIER'S PREVIOUS LEAVE OVERLAPS WITH THE SYSTEM DATE
    SELECT COUNT(*) INTO LEAVE_COUNT
    FROM LEAVEMODULE
    WHERE SOLDIERID = :NEW.SOLDIERID
        AND (LEAVESTARTDATE <= SYSDATE AND SYSDATE <= LEAVEENDDATE);

    -- IF THE SOLDIER'S PREVIOUS LEAVE OVERLAPS WITH THE SYSTEM DATE, RAISE AN EXCEPTION
    IF LEAVE_COUNT > 0 THEN
        RAISE_APPLICATION_ERROR(-20001, 'SOLDIER IS ALREADY ON LEAVE');
    END IF;
END;


/

CREATE OR REPLACE TRIGGER CHECK_TEMP_ERE_TRIGGER
BEFORE UPDATE ON SOLDIER
FOR EACH ROW
BEGIN
    IF :NEW.TEMPORARYCOMMAND = 'YES' AND :NEW.ERE = 'YES' THEN
        RAISE_APPLICATION_ERROR(-20001, 'A SOLDIER CANNOT BE IN TEMPORARY COMMAND AND ERE SIMULTANEOUSLY.');
    END IF;
    else 
END;


-- CREATE FUNCTIONS



--INSERT ADMIN

