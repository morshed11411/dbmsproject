CREATE OR REPLACE FUNCTION CalculateAge(DateOfBirth DATE) RETURN NUMBER DETERMINISTIC IS
BEGIN
  RETURN TRUNC(MONTHS_BETWEEN(SYSDATE, DateOfBirth) / 12);
END;
/

ALTER TABLE Soldier ADD Age NUMBER GENERATED ALWAYS AS (CalculateAge(DateOfBirth));




CREATE SEQUENCE MedicalIDSeq
  START WITH 1
  INCREMENT BY 1
  NOMAXVALUE;


CREATE OR REPLACE TRIGGER MedicalIDTrigger
BEFORE INSERT ON MedicalInfo
FOR EACH ROW
BEGIN
  SELECT MedicalIDSeq.NEXTVAL INTO :new.MedicalID FROM dual;
END;
/


CREATE OR REPLACE VIEW manage_company_view AS
SELECT
  C.COMPANYID,
  C.COMPANYNAME,
  S.NAME AS "Coy Comd",
  (SELECT COUNT(*) FROM SOLDIER WHERE COMPANYID = C.COMPANYID) AS TotalManpower
FROM
  COMPANY C
  JOIN SOLDIER S ON C.COMPANYID = S.COMPANYID
  JOIN SOLDIERAPPOINTMENT SA ON S.SOLDIERID = SA.SOLDIERID
  JOIN APPOINTMENTS A ON SA.APPOINTMENTID = A.APPOINTMENTID
WHERE
  A.APPOINTMENTNAME = 'COY COMD';




CREATE OR REPLACE VIEW todays_leave_view AS
SELECT s.SoldierID, s.Name, r.Rank, t.Trade, c.CompanyName, l.LeaveType, l.LeaveStartDate, l.LeaveEndDate,
       (l.LeaveEndDate - TRUNC(SYSDATE)) AS RemainingLeave
FROM Soldier s
JOIN Ranks r ON s.RankID = r.RankID
JOIN Trade t ON s.TradeID = t.TradeID
JOIN Company c ON s.CompanyID = c.CompanyID
JOIN LeaveModule l ON s.SoldierID = l.SoldierID
WHERE l.LeaveStartDate <= TRUNC(SYSDATE)
AND l.LeaveEndDate >= TRUNC(SYSDATE);


CREATE OR REPLACE TRIGGER check_leave_trigger
BEFORE INSERT OR UPDATE ON LeaveModule
FOR EACH ROW
DECLARE
    leave_count NUMBER;
BEGIN
    -- Check if the soldier's previous leave overlaps with the system date
    SELECT COUNT(*) INTO leave_count
    FROM LeaveModule
    WHERE SoldierID = :NEW.SoldierID
        AND (LeaveStartDate <= SYSDATE AND SYSDATE <= LeaveEndDate);

    -- If the soldier's previous leave overlaps with the system date, raise an exception
    IF leave_count > 0 THEN
        RAISE_APPLICATION_ERROR(-20001, 'Soldier is already on leave');
    END IF;
END;
/



CREATE OR REPLACE FUNCTION CalculateIsPresent(p_soldier_id IN NUMBER)
  RETURN NUMBER
DETERMINISTIC
IS
  l_leave_count NUMBER;
  l_temp_command VARCHAR2(3);
  l_ere VARCHAR2(3);
  l_serving_status VARCHAR2(10);
BEGIN
  -- Check if the soldier is on leave
  SELECT COUNT(*) INTO l_leave_count
  FROM TODAYS_LEAVE_VIEW
  WHERE SoldierID = p_soldier_id;

  -- Check the soldier's temporary command, ere, and serving status
  SELECT TemporaryCommand, ERE, ServingStatus
  INTO l_temp_command, l_ere, l_serving_status
  FROM Soldier
  WHERE SoldierID = p_soldier_id;

  -- Return 0 if soldier is on leave or meets additional conditions, 1 otherwise
  RETURN CASE
    WHEN l_leave_count > 0 THEN 0
    WHEN l_temp_command = 'Yes' OR l_ere = 'Yes' OR l_serving_status <> 'Serving' THEN 0
    ELSE 1
  END;
END;
/



ALTER TABLE Soldier DROP COLUMN ISPRESENT;

ALTER TABLE Soldier ADD ISPRESENT GENERATED ALWAYS AS (CalculateIsPresent(SoldierID)) VIRTUAL;

CREATE OR REPLACE VIEW AbsentSoldiersView AS
SELECT s.SoldierID, s.Name, r.Rank, c.CompanyName, 'ERE' AS Reason 
FROM Soldier s
JOIN Ranks r ON s.RankID = r.RankID
JOIN Company c ON s.CompanyID = c.CompanyID
WHERE s.ERE = 'Yes'
UNION
SELECT s.SoldierID, s.Name, r.Rank, c.CompanyName, 'Temporary Command' AS Reason 
FROM Soldier s
JOIN Ranks r ON s.RankID = r.RankID
JOIN Company c ON s.CompanyID = c.CompanyID
WHERE s.TemporaryCommand = 'Yes'
UNION
SELECT s.SoldierID, s.Name, r.Rank, c.CompanyName, 'AWOL' AS Reason 
FROM Soldier s
JOIN Ranks r ON s.RankID = r.RankID
JOIN Company c ON s.CompanyID = c.CompanyID
WHERE s.ServingStatus = 'AWOL'
UNION
SELECT tl.SoldierID, s.Name, r.Rank, c.CompanyName, tl.LeaveType AS Reason
FROM Todays_Leave_View tl
JOIN Soldier s ON tl.SoldierID = s.SoldierID
JOIN Ranks r ON s.RankID = r.RankID
JOIN Company c ON s.CompanyID = c.CompanyID
UNION
SELECT m.SoldierID, s.Name, r.Rank, c.CompanyName, m.DisposalType AS Reason
FROM TODAYS_DISPOSAL_HOLDER m
JOIN Soldier s ON m.SoldierID = s.SoldierID
JOIN Ranks r ON s.RankID = r.RankID
JOIN Company c ON s.CompanyID = c.CompanyID;

CREATE OR REPLACE VIEW parade_state_view AS
SELECT
  c.COMPANYNAME,
  a.MANPOWER AS "Auth",
  COUNT(s.SOLDIERID) AS "Granted",
  COUNT(l.SOLDIERID) AS "Leave",
  COUNT(CASE WHEN s.ISPRESENT = 0 THEN 1 END) AS "Absent",
  COUNT(s.SOLDIERID) - COUNT(CASE WHEN s.ISPRESENT = 0 THEN 1 END) AS "Present",
  COUNT(d.SOLDIERID) AS "MedicalDisposal"
FROM
  COMPANY c
LEFT JOIN
  AUTHORIZATION a ON c.COMPANYID = a.COMPANYID
LEFT JOIN
  SOLDIER s ON c.COMPANYID = s.COMPANYID
LEFT JOIN
  TODAYS_LEAVE_VIEW l ON s.SOLDIERID = l.SOLDIERID
LEFT JOIN
  TODAYS_DISPOSAL_HOLDER d ON s.SOLDIERID = d.SOLDIERID
GROUP BY
  c.COMPANYNAME, a.MANPOWER;




CREATE OR REPLACE FUNCTION CalculateIsPresent(p_soldier_id IN NUMBER)
  RETURN NUMBER
DETERMINISTIC
IS
  l_leave_count NUMBER;
  l_temp_command VARCHAR2(3);
  l_ere VARCHAR2(3);
  l_serving_status VARCHAR2(10);
  l_disposal_count NUMBER;
BEGIN
  -- Check if the soldier is on leave
  SELECT COUNT(*) INTO l_leave_count
  FROM TODAYS_LEAVE_VIEW
  WHERE SoldierID = p_soldier_id;

  -- Check the soldier's temporary command, ere, and serving status
  SELECT TemporaryCommand, ERE, ServingStatus
  INTO l_temp_command, l_ere, l_serving_status
  FROM Soldier
  WHERE SoldierID = p_soldier_id;
  
  -- Check if the soldier has a disposal today
  SELECT COUNT(*) INTO l_disposal_count
  FROM MedicalInfo
  WHERE SOLDIERID = p_soldier_id
    AND TRUNC(STARTDATE) <= TRUNC(SYSDATE)
    AND TRUNC(ENDDATE) >= TRUNC(SYSDATE);

  -- Return 0 if soldier is on leave, has a disposal today, or meets additional conditions, 1 otherwise
  RETURN CASE
    WHEN l_leave_count > 0 THEN 0
    WHEN l_temp_command = 'Yes' OR l_ere = 'Yes' OR l_serving_status <> 'Serving' OR l_disposal_count > 0 THEN 0
    ELSE 1
  END;
END;
/


CREATE OR REPLACE TRIGGER check_medical_disposal_trigger
BEFORE INSERT ON MedicalInfo
FOR EACH ROW
DECLARE
    disposal_count NUMBER;
BEGIN
    -- Check if there are any overlapping disposal dates for the soldier
    SELECT COUNT(*) INTO disposal_count
    FROM MedicalInfo
    WHERE SoldierID = :NEW.SoldierID
        AND ((:NEW.StartDate >= StartDate AND :NEW.StartDate <= EndDate)
            OR (:NEW.EndDate >= StartDate AND :NEW.EndDate <= EndDate));
            
    -- If there are overlapping disposal dates, raise an exception
    IF disposal_count > 0 THEN
        RAISE_APPLICATION_ERROR(-20001, 'Medical disposal dates overlap for the soldier');
    END IF;
END;
/


CREATE SEQUENCE LOG_ID_SEQUENCE START WITH 1 INCREMENT BY 1;
CREATE TABLE LOGGING_TABLE (
  log_id NUMBER PRIMARY KEY,
  soldier_id NUMBER,
  operation VARCHAR2(10),
  table_name VARCHAR2(100),
  timestamp TIMESTAMP
);
CREATE OR REPLACE TRIGGER log_changes_trigger
AFTER INSERT OR UPDATE OR DELETE ON SCHEMA
FOR EACH ROW
DECLARE
    -- Declare variables to store the necessary logging information
    log_id NUMBER;
    soldier_id NUMBER;
    operation VARCHAR2(10);
    table_name VARCHAR2(100);
    timestamp TIMESTAMP;
BEGIN
    -- Get the soldier ID from the affected row
    soldier_id := :NEW.SOLDIERID; -- Assuming the soldier ID column is named SOLDIERID

    -- Get the current timestamp
    timestamp := CURRENT_TIMESTAMP;

    -- Determine the DML operation (insert, update, or delete)
    IF INSERTING THEN
        operation := 'INSERT';
    ELSIF UPDATING THEN
        operation := 'UPDATE';
    ELSIF DELETING THEN
        operation := 'DELETE';
    END IF;

    -- Get the table name of the affected table
    table_name := ora_dict_obj_name;

    -- Generate a unique log ID using the sequence
    SELECT LOG_ID_SEQUENCE.NEXTVAL INTO log_id FROM DUAL;

    -- Insert the log entry into the logging table
    INSERT INTO LOGGING_TABLE (log_id, soldier_id, operation, table_name, timestamp)
    VALUES (log_id, soldier_id, operation, table_name, timestamp);
END;
/
CREATE OR REPLACE TRIGGER log_soldier_table
AFTER INSERT OR UPDATE OR DELETE ON SOLDIER
FOR EACH ROW
DECLARE
  v_operation VARCHAR2(10);
BEGIN
  -- Get the logged-in soldier's ID from the session
  -- Replace 'SESSION_SOLDIER_ID' with the appropriate session attribute that holds the soldier ID
  -- For example, if you store the soldier ID in the 'SESSION_SOLDIER_ID' attribute, use SYS_CONTEXT('USERENV', 'SESSION_SOLDIER_ID')
  -- Alternatively, you can use a package or other mechanism to retrieve the soldier ID
  -- Ensure that the session attribute is set correctly when the user logs in
  -- The example assumes that the session attribute is a number type
  v_soldier_id := SYS_CONTEXT('USERENV', 'userid');
  
  IF INSERTING THEN
    v_operation := 'INSERT';
  ELSIF UPDATING THEN
    v_operation := 'UPDATE';
  ELSIF DELETING THEN
    v_operation := 'DELETE';
  END IF;
  
  INSERT INTO LOGGING_TABLE (log_id, soldier_id, operation, table_name, timestamp)
  VALUES (LOG_ID_SEQUENCE.NEXTVAL, v_soldier_id, v_operation, 'SOLDIER_TABLE', SYSTIMESTAMP);
END;
/

CREATE OR REPLACE TRIGGER check_temp_ere_trigger
BEFORE INSERT OR UPDATE ON Soldier
FOR EACH ROW
BEGIN
    IF :NEW.TemporaryCommand = 'Yes' AND :NEW.ERE = 'Yes' THEN
        RAISE_APPLICATION_ERROR(-20001, 'A soldier cannot be in Temporary Command and ERE simultaneously.');
    END IF;
END;
/


CREATE OR REPLACE TRIGGER awol_notification_trigger
BEFORE INSERT OR UPDATE ON Soldier
FOR EACH ROW
DECLARE
    v_soldier_name Soldier.NAME%TYPE;
BEGIN
    IF :NEW.SERVINGSTATUS = 'AWOL' THEN
        SELECT NAME INTO v_soldier_name FROM Soldier WHERE SOLDIERID = :NEW.SOLDIERID;
        RAISE_APPLICATION_ERROR(-20001, 'Notification: Soldier ' || v_soldier_name || ' is AWOL.');
    END IF;
END;
/
